"""
Verification script for blockchain worker testing.

This script queries the database to verify that the worker correctly processed
all blockchain events generated by interact.py.

Usage:
    uv run python tests/integration/blockchain/verify_worker.py
"""

import asyncio
import os
from decimal import Decimal

import asyncpg
from dotenv import load_dotenv

# Load test environment variables
load_dotenv(".env.test")

DATABASE_URL = os.getenv("DATABASE_URL")


def print_section(title: str) -> None:
    """Print section header."""
    print(f"\n{'=' * 80}")
    print(f"  {title}")
    print(f"{'=' * 80}\n")


def print_result(check: str, passed: bool, details: str = "") -> None:
    """Print verification result."""
    icon = "✅" if passed else "❌"
    print(f"{icon} {check}")
    if details:
        print(f"   {details}\n")


async def verify_events(conn: asyncpg.Connection) -> tuple[bool, int]:
    """Verify that events were stored correctly."""
    print_section("Checking Event Storage")
    
    events = await conn.fetch("SELECT event_name, tx_hash, block_number FROM onchain_events ORDER BY block_number")
    
    if not events:
        print_result("Events stored", False, "No events found in database")
        return False, 0
    
    print(f"Found {len(events)} events:\n")
    for event in events:
        print(f"  - {event['event_name']:20s} | Block {event['block_number']:6d} | TX: {event['tx_hash'][:16]}...")
    
    # Check for expected event types
    event_names = {event['event_name'] for event in events}
    required_events = ["AGREEMENT_CREATED", "PAYMENT_FUNDED", "PAYMENT_RELEASED"]
    
    passed = all(event in event_names for event in required_events)
    print_result(
        "Required events present",
        passed,
        f"Expected: {required_events}" if not passed else ""
    )
    
    return passed, len(events)


async def verify_agreements(conn: asyncpg.Connection) -> bool:
    """Verify that agreements were updated correctly."""
    print_section("Checking Agreement States")
    
    agreements = await conn.fetch("""
        SELECT agreement_id, status, created_tx_hash, funded_tx_hash, released_tx_hash, refunded_tx_hash
        FROM agreements
        ORDER BY created_at
    """)
    
    if not agreements:
        print_result("Agreements found", False, "No agreements in database")
        return False
    
    print(f"Found {len(agreements)} agreements:\n")
    all_passed = True
    
    for agreement in agreements:
        agreement_id = str(agreement['agreement_id'])[:20] + "..."
        status = agreement['status']
        
        print(f"  Agreement {agreement_id}")
        print(f"    Status: {status}")
        
        # Check that status transitions match transaction hashes
        checks = []
        
        if agreement['created_tx_hash']:
            checks.append(("Created on-chain", True))
        
        if status in ["FUNDED", "DISPUTED", "RELEASED", "REFUNDED"]:
            has_funded_tx = agreement['funded_tx_hash'] is not None
            checks.append(("Funded transaction", has_funded_tx))
            if not has_funded_tx:
                all_passed = False
        
        if status == "RELEASED":
            has_released_tx = agreement['released_tx_hash'] is not None
            checks.append(("Release transaction", has_released_tx))
            if not has_released_tx:
                all_passed = False
        
        if status == "REFUNDED":
            has_refunded_tx = agreement['refunded_tx_hash'] is not None
            checks.append(("Refund transaction", has_refunded_tx))
            if not has_refunded_tx:
                all_passed = False
        
        for check_name, check_passed in checks:
            print_result(f"      {check_name}", check_passed)
        
        print()
    
    return all_passed


async def verify_users(conn: asyncpg.Connection) -> bool:
    """Verify that users were created from blockchain addresses."""
    print_section("Checking User Creation")
    
    users = await conn.fetch("SELECT wallet_address FROM users WHERE wallet_address IS NOT NULL")
    
    if not users:
        print_result("Users created", False, "No users with wallet addresses found")
        return False
    
    print(f"Found {len(users)} users with wallet addresses:\n")
    for user in users:
        print(f"  - {user['wallet_address']}")
    
    print()
    print_result("Users created from blockchain", len(users) > 0)
    
    return len(users) > 0


async def verify_disputes(conn: asyncpg.Connection) -> bool:
    """Verify that disputes were created and resolved correctly."""
    print_section("Checking Dispute Records")
    
    disputes = await conn.fetch("""
        SELECT agreement_id, resolution, resolution_tx_hash
        FROM disputes
        ORDER BY opened_at
    """)
    
    if not disputes:
        print("No disputes found (may be expected if only happy path was tested)")
        return True
    
    print(f"Found {len(disputes)} disputes:\n")
    all_passed = True
    
    for dispute in disputes:
        agreement_id = str(dispute['agreement_id'])[:20] + "..."
        resolution = dispute['resolution']
        has_resolution_tx = dispute['resolution_tx_hash'] is not None
        
        print(f"  Dispute for Agreement {agreement_id}")
        print(f"    Resolution: {resolution or 'PENDING'}")
        
        if resolution and not has_resolution_tx:
            print_result("      Resolution transaction", False)
            all_passed = False
        elif resolution:
            print_result("      Resolution transaction", True)
        
        print()
    
    return all_passed


async def verify_sync_state(conn: asyncpg.Connection) -> bool:
    """Verify that sync state was updated."""
    print_section("Checking Sync State")
    
    state = await conn.fetchrow("SELECT last_processed_block, last_finalized_block FROM chain_sync_state LIMIT 1")
    
    if not state:
        print_result("Sync state exists", False, "No sync state found")
        return False
    
    print(f"Last processed block: {state['last_processed_block']}")
    print(f"Last finalized block: {state['last_finalized_block']}\n")
    
    passed = state['last_processed_block'] > 0
    print_result("Sync state updated", passed)
    
    return passed


async def main() -> None:
    """Main verification execution."""
    print_section("Blockchain Worker Verification Suite")
    
    if not DATABASE_URL:
        print("ERROR: DATABASE_URL not set in .env.test")
        return
    
    # Parse DATABASE_URL for asyncpg
    db_url = DATABASE_URL.replace("postgresql+asyncpg://", "postgresql://")
    
    try:
        conn = await asyncpg.connect(db_url)
    except Exception as e:
        print(f"ERROR: Cannot connect to database")
        print(f"  {e}")
        return
    
    try:
        print(f"Connected to database\n")
        
        # Run all verification checks
        results = {}
        
        results['events'], event_count = await verify_events(conn)
        results['agreements'] = await verify_agreements(conn)
        results['users'] = await verify_users(conn)
        results['disputes'] = await verify_disputes(conn)
        results['sync_state'] = await verify_sync_state(conn)
        
        # Summary
        print_section("Verification Summary")
        
        total_checks = len(results)
        passed_checks = sum(1 for passed in results.values() if passed)
        
        print(f"Passed: {passed_checks}/{total_checks} checks")
        print(f"Total events processed: {event_count}\n")
        
        if passed_checks == total_checks:
            print("All verifications passed!")
        else:
            print("Some verifications failed. Check the details above.")
            print("Make sure the worker is running and has had time to process events.")
        
    finally:
        await conn.close()


if __name__ == "__main__":
    asyncio.run(main())
